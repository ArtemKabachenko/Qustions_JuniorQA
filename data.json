[ 
    {
      "title": "Що таке інтернет та як він працює?",
      "content": "Інтернет це глобальна мережа в якій всі пристрої з'єднані між собою та мають свій унікальний ідентифікатор IP, та за допомогою протоколів ці пристрої можуть обмінюватись даними."
    },
    {
      "title": "З чого складається URI?",
      "content": "<ol><li>Протокол передачі даних https://</li><li>subdomain.domain.root_domain</li><li>port (http-80, https-443), але він не показується за замовченням</li><li>path - путь до конкретної сторінки або файлу на сайті</li><li>query param - фільтри, сортування, доп. параметри</li><li>anchor - якір, для переходу до певної частини сторінки</li></ol>"
    },
    {
      "title": "Що таке DNS, IP, domain?",
      "content": "<b>DNS</b>: Система, яка перетворює доменні імена (наприклад, google.com) в IP-адреси. <br><b>IP-адреса</b>: Кожен пристрій має унікальну IP-адресу, яка слугує ідентифікатором у мережі"
    },
    {
        "title":
            "Що таке клієнт-серверна архітектура?",
        "content": 
            "Клієнт-серверна архітектура - це спосіб організації взаємодії між пристроями, де клієнт запитує дані або послуги, а сервер їх надає. <br>Існують однорангові та багаторангові архітектури <br><b>однорангові</b> - клієнт - клієнт <br><b>багаторангові</b> - клієнт - сервер - БД <br>На сервері зберігається код додатка, та виконується логіка <br>А в Базі Даних зберігається самі дані, та там ми можемо швидко шукати їх."
    },
    {
      "title":
          "Що може виступати в ролі клієнта?",
      "content": 
          "В ролі клієнта виступає - <b>браузер</b>, <b>мобільний додаток</b>, або <b>десктоп додаток</b>"
    },
    {
      "title":
          "Які браузери ви знаєте? У чому їх відмінність?",
      "content": 
          "<b>Google Chrome</b> — швидкий, простий у використанні, інтегрований із сервісами Google, але споживає багато пам’яті. </br><b>Mozilla Firefox</b> — безпечний, налаштовуваний, підтримує конфіденційність, але трохи повільніший за Chrome. </br><b>Microsoft Edge</b> — швидкий, інтегрований із Windows, енергоефективний, має функції для роботи з PDF. </br><b>Safari</b> — оптимізований для пристроїв Apple, енергоефективний і швидкий, але доступний лише на macOS та iOS. </br><b>Opera</b> — має вбудований VPN, блокувальник реклами та компактний дизайн, але менш популярний. </br><b>Tor Browser</b> — забезпечує анонімність і доступ до мережі Tor, але повільніший через захист даних."
    },
    {
      "title":
          "Що таке OSI model?",
      "content": 
          "Open Systems Interconnection model - модель зв'язки мережевих протоколів. <br>За допомогою цієї моделі різні пристрої можуть взаємодіяти один з одним.</br>Є <b>сім рівнів</b> в цій моделі:</br>1) <b>Фізичний рівень</b> (Physical layer):<br>Відповідає за передачу сигналів через фізичне середовище (дроти, оптоволокно, радіохвилі).<br>Приклад: кабелі Ethernet, Wi-Fi.<br>2) <b>Канальний</b> рівень (Data Link layer):<br>Забезпечує передачу даних між пристроями в межах однієї мережі та виправляє помилки.<br>Приклад: MAC-адреса, протоколи Ethernet.<br>3) <b>Мережевий рівень</b> (Network layer):<br>Відповідає за маршрутизацію даних між різними мережами.<br>Приклад: IP-адреса, протокол IP (IPv4, IPv6).<br>4) <b>Транспортний рівень</b> (Transport layer):<br>Забезпечує надійність передачі даних, контроль цілісності та їх послідовність.<br>Приклад: TCP (надійний) та UDP (швидкий).<br>5) <b>Сеансовий рівень</b> (Session layer):<br>Керує встановленням, підтримкою та завершенням сеансів зв'язку між пристроями.<br>Приклад: протокол NetBIOS.<br>6) <b>Рівень представлення</b> (Presentation layer):<br>Перетворює дані у формат, зрозумілий додаткам, і шифрує/розшифровує їх.<br>Приклад: SSL/TLS, кодування ASCII.<br>7) <b>Прикладний рівень</b> (Application layer):<br>Забезпечує доступ користувачам до мережевих сервісів і програм.<br>Приклад: HTTP, FTP, SMTP (електронна пошта)."
    },
    {
      "title":
          "Які протоколи передачі даних ви знаєте?",
      "content": 
          "Найпопулярніші протоколи з якими працюють програмісти:<br><br><b>Транспортний рівень</b>:<br><b>TCP</b> - це протокол який встановлює handshake, надає надійність передачі даних<br><b>UDP</b> - цей протокол не має handshake, але гарантує швидкість передачі даних<br><b>QUIC</b> - надбудова над протоколом UDP який, і надійний, і гарантує швидкість передачі даних<br><br><b>Прикладний рівень</b>:<br><b>HTTP</b> (HyperText Transfer Protocol) — це протокол передачі гіпертексту, який використовується для обміну даними між веб-браузером (клієнтом) і веб-сервером.<br><b>FTP</b> (File Transfer Protocol) — це протокол для передачі файлів між комп'ютерами в мережі. Він дозволяє завантажувати файли з сервера на клієнт і завантажувати файли з клієнта на сервер. FTP не забезпечує шифрування, що робить його незахищеним"
    },
    {
      "title":
          "Різниця між TCP та UDP + QUIC",
      "content": 
          "<b>TCP</b> - надійність, упорядкованість, важкий<br><b>UDP</b> - ненадійність, неупорядкованість, легкий<br><b>QUIC</b>- надійність, упорядкованість, легкий"
    },
    {
      "title":
          "Чим відрізняється HTTP від HTTPS?",
      "content": 
          "HTTPS = HTTP + TCP + TLS (S = Secure)<br>HTTPS - надає надійність передачі даних у зв'язку з протоколом TLS."
    },
    {
      "title":
          "Які HTTP-методи ви знаєте?",
      "content": 
          "GET, POST, PUT, PATCH, DELETE, OPTIONS, TRACE, CONNECT, HEAD<br><br><b>GET</b>: Отримати ресурс.<br><b>POST</b>: Надіслати дані на сервер (наприклад, при заповненні форми).<br><b>PUT</b>: Повністю оновити ресурс.<br><b>PATCH</b>: Часткове оновлення ресурсу.<br><b>DELETE</b>: Видалити ресурс.<br><b>OPTIONS</b>: Запит на отримання доступних методів для ресурсу або сервера, працює як ping.<br><b>TRACE</b>: Використовується для діагностики, повертає те саме, що було надіслано в запиті.<br><b>CONNECT</b>: Використовується для створення тунелю (зазвичай для HTTPS-з'єднань через проксі).<br><b>HEAD</b>: Запит на отримання тільки заголовків відповіді без тіла, корисний для перевірки метаданих."
    },
    {
      "title":
          "З чого складається HTTP запит?",
      "content": 
          "1) Метод<br>2) Протокол<br>3) URL<br>4) Заголовки (Headers)<br>5) Тіло запиту (Body)"
    },
    {
      "title":
          "Які приклади HTTP headers ви знаєте?",
      "content": 
          "<b>Заголовки запиту (Request Headers)</b>:<br><br><b>User-Agent</b> — інформує сервер про тип клієнта (браузер або програму), що здійснює запит.<br>Приклад: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36<br><b>Accept</b> — визначає типи медіа, які клієнт готовий приймати від сервера.<br>Приклад: Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><b>Authorization</b> — містить облікові дані для авторизації на сервері.<br>Приклад: Authorization: Bearer <token><br><b>Content-Type</b> — вказує формат тіла запиту, наприклад, при надсиланні форм або даних.<br>Приклад: Content-Type: application/json<br><b>Accept-Language</b> — вказує переваги щодо мов, які клієнт може приймати.<br>Приклад: Accept-Language: en-US,en;q=0.9,uk;q=0.8<br><b>Cookie</b> — передає збережені cookies від клієнта до сервера.<br>Приклад: Cookie: sessionId=abc123; user=JohnDoe<br><br><b>Заголовки відповіді (Response Headers)</b>:<br><br><b>Content-Type</b> — визначає тип вмісту відповіді.<br>Приклад: Content-Type: application/json; charset=UTF-8<br><b>Cache-Control</b> — вказує, як і де можна кешувати відповідь.<br>Приклад: Cache-Control: no-cache, no-store, must-revalidate<br><b>Location</b> — використовується для перенаправлення (редиректу) на іншу URL-адресу.<br>Приклад: Location: https://example.com/new-page<br><b>Set-Cookie</b> — відправляє cookies на клієнт.<br>Приклад: Set-Cookie: sessionId=abc123; Path=/; Secure; HttpOnly<br><b>Content-Length</b> — вказує довжину тіла відповіді в байтах.<br>Приклад: Content-Length: 348<br><b>Server</b> — надає інформацію про сервер, що обробив запит.<br>Приклад: Server: Apache/2.4.1 (Unix)"
    },
    {
      "title":
          "Чи є у HTTP пріоритет запитів?",
      "content": 
          "Так є, у http 2 та http 3. Вирішує браузер які запити надсилати першими"
    },
    {
      "title":
          "Хто вирішує яку версію протоколу використовувати?",
      "content": 
          "Браузер та сервер, домовляються яку версію вони підтримують. Ця домовленість відбувається в handshake"
    },
    {
      "title":
          "Чим відрізняється GET від POST?",
      "content": 
          "<b>GET</b>: <br>- Використовується для отримання інформації з сервера. <br>- Дані передаються через URL в рядку запиту<br>- Максимальна довжина запиту 2048 символів<br><br><b>POST</b>: <br>- Використовується для надсилання даних на сервер (наприклад, при заповненні форм). Зазвичай змінює стан сервера (створює або оновлює ресурси).<br>- Дані передаються в тілі запиту (body)<br>- Немає обмежень на кількість"
    },
    {
      "title":
          "Чи існує у GET метода Request body?",
      "content": 
          "Він існує, але його не заведено надсилати"
    },
    {
      "title":
          "Чим відрізняється PUT від PATCH?",
      "content": 
          "<b>PUT</b>: Оновлює або замінює існуючий ресурс повністю, не вказані поля будуть замінені значеннями за замовчуванням або видалені. Якщо ресурс не існує, зазвичай створюється новий.<br><br><b>PATCH</b>: Оновлює лише частину ресурсу, лише ті дані, які вказані в запиті. Інші частини ресурсу залишаються без змін."
    },
    {
      "title":
          "Охарактеризуйте кожен клас статус-кодів (1xx, 2xx, 3xx, 4xx, 5xx)",
      "content": 
          "<b>1xx: Інформаційні (Informational)</b><br>Ці статус-коди повідомляють, що сервер отримав запит і процес обробки триває.<br>Призначення: Вказати клієнту, що запит прийнятий, але ще не завершений.<br>Приклади:<br>100 Continue: Сервер отримав початкову частину запиту, клієнт може продовжувати його надсилати.<br>101 Switching Protocols: Сервер погодився змінити протокол (наприклад, з HTTP на WebSocket).<br>103 Early Hints: Сервер повідомляє ранні заголовки для підготовки клієнта.<br><br><b>2xx: Успішні (Successful)</b><br>Ці статус-коди означають, що запит був успішно отриманий, оброблений і сервер повернув результат.<br>Призначення: Підтвердити успішне виконання запиту.<br>Приклади:<br>200 OK: Успішний запит, результат міститься у відповіді.<br>201 Created: Запит успішно завершено, і створено новий ресурс.<br>202 Accepted: Запит прийнятий, але ще не оброблений.<br>204 No Content: Успішний запит, але без контенту у відповіді.<br><br><b>3xx: Перенаправлення (Redirection)</b><br>Ці статус-коди вказують, що для виконання запиту потрібно виконати додаткові дії (наприклад, перейти на іншу URL-адресу).<br>Призначення: Повідомити клієнту про необхідність перенаправлення.<br>Приклади:<br>301 Moved Permanently: Ресурс постійно переміщено на іншу адресу.<br>302 Found: Тимчасове перенаправлення на іншу адресу.<br>304 Not Modified: Ресурс не змінювався з часу останнього запиту (використовується для кешування).<br><br><b>4xx: Помилки клієнта (Client Error)</b><br>Ці статус-коди повідомляють, що клієнт надіслав некоректний запит.<br>Призначення: Сповістити клієнта про помилку, спричинену його діями.<br>Приклади:<br>400 Bad Request: Некоректний запит (наприклад, синтаксична помилка).<br>401 Unauthorized: Необхідна авторизація.<br>403 Forbidden: Доступ до ресурсу заборонений.<br>404 Not Found: Ресурс не знайдено.<br>429 Too Many Requests: Занадто багато запитів за короткий час.<br><br><b>5xx: Помилки сервера (Server Error)</b><br>Ці статус-коди вказують на помилки, що виникли на стороні сервера під час обробки запиту.<br>Призначення: Повідомити клієнта, що проблема виникла на стороні сервера.<br>Приклади:<br>500 Internal Server Error: Загальна помилка сервера.<br>502 Bad Gateway: Сервер отримав некоректну відповідь від іншого сервера.<br>503 Service Unavailable: Сервер тимчасово недоступний (наприклад, через перевантаження).<br>504 Gateway Timeout: Сервер не отримав відповідь вчасно від іншого сервера."
    },
    {
      "title":
          "Яка різниця між 401 та 403 кодом?",
      "content": 
          "<b>401</b> - не залогінен, потрібна авторизація<br><br><b>403</b> - залогінен, але немає доступу"
    },
    {
      "title":
          "Може сервер надіслати код 400, якщо проблема на його боці?",
      "content": 
          "Ні, для помилок, які виникають через проблеми на сервері, використовуються 5xx статус-коди"
    },
    {
      "title":
          "Що таке XML і JSON, які відмінності між ними?",
      "content": 
          "XML (Extensible Markup Language) і JSON (JavaScript Object Notation) — це формати для зберігання і обміну даними.<br><br><b>XML</b>: Розширюваний формат із тегами, що структурно нагадує HTML. Він дозволяє створювати власні теги та структури для даних, що робить його дуже гнучким, але й об'ємним. Використовується в системах, де потрібна складна структура або розширюваність<br><br><b>JSON</b>: Це легкий формат для обміну даними, що базується на синтаксисі JavaScript. JSON використовує пари \"ключ-значення\" і здебільшого застосовується для обміну даними в веб-додатках та API. JSON зазвичай коротший, легший для читання і обробки, ніж XML."
    },
    {
      "title":
          "Які типи даних підтримує JSON?",
      "content": 
          "JSON підтримує такі типи даних:<br><br><b>Строки</b>: \"Hello, World!\"<br><b>Числа</b>: 42, 3.14<br><b>Логічні значення</b>: true, false<br><b>Масиви</b>: [1, 2, 3]<br><b>Об'єкти</b>: {\"key\": \"value\"}<br><b>null</b>: null"
    },
    {
      "title":
          "Яке максимальне число можна помістити в JSON?",
      "content": 
          "Проблеми починаються з занадто великими числами рекомендується не більше 2⁵³-1"
    },
    {
      "title":
          "Що таке Cache? Види Cache? Що зберігає?",
      "content": 
          "<b>Cache (кеш)</b> — це швидка пам'ять або сховище, яке використовується для тимчасового зберігання даних, що часто використовуються, та яким не критично бути актуальними<br><br><b>Кеш зберігає</b>: часто використовувані веб-сторінки, зображення, відео, JavaScript, CSS<br><br><b>Види кешу</b>:<br><b>Кеш браузера (Browser Cache)</b>:<br>Зберігає статичні файли веб-сайтів (зображення, CSS, JavaScript) на пристрої користувача.<br>Дозволяє швидше завантажувати сторінки при наступних відвідинах, оскільки не потрібно завантажувати одні й ті самі ресурси знову.<br><br><b>Кеш серверу (Server Cache)</b>:<br>Сервери можуть зберігати результати обробки запитів (наприклад, сторінки або API-відповіді), щоб зменшити навантаження і час відгуку для наступних запитів.<br><br><b>Кеш бази даних (Database Cache)</b>:<br>Використовується для зберігання часто запитуваних результатів запитів до бази даних. Це дозволяє знизити навантаження на саму базу даних і прискорити обробку запитів.<br><br><b>Кеш процесора (CPU Cache)</b>:<br>Це кеш пам'яті, який безпосередньо інтегрований в процесор для швидкого доступу до даних, які часто використовуються, зменшуючи час доступу до оперативної пам'яті."
    },
    {
      "title":
          "Який Http header відповідає скільки часу зберігати cache?",
      "content": 
          "Cache-Control"
    },
    {
      "title":
          "Що таке Cookie? Що зберігає? Навіщо потрібні?",
      "content": 
          "Cookie (кукі) — це маленькі фрагменти даних, які зберігаються на стороні клієнта (у браузері). <br>Cookie може встановлювати як фронт, так і бек, діляться на:<br><b>Авторизаційні</b> - токен - надсилає сервер<br><b>Маркетингові</b> - аналітика сайту, які товари дивився, кліки, статті<br><b>Пов'язані з роботою на сайті</b> - інформація про товари в кошику, тема сайту, мова<br>Ще у Cookie є <b>домен</b> і <b>термін життя</b> (header set-cookie)"
    },
    {
      "title":
          "Як зробити, щоб JS код на клієнті не зміг прочитати Cookie?",
      "content": 
          "Використовувати атрибут httpOnly"
    },
    {
      "title":
          "Як зробити, щоб Cookie передавались тільки по HTTPS?",
      "content": 
          "Використовувати атрибут secure"
    },
    {
      "title":
          "Що таке Local storage? Що зберігає?",
      "content": 
          "Local Storage — це веб-технологія, яка дозволяє веб-сайтам зберігати дані в браузері на стороні клієнта (користувача) без обмеження часу. Дані зберігаються в локальному сховищі браузера і доступні навіть після закриття браузера або перезавантаження сторінки.<br>Local Storage зберігає дані у вигляді рядків та мають вигляд пар \"ключ-значення\""
    },
    {
      "title":
          "Що таке ідентифікація, аутентифікація, авторизація?",
      "content": 
          "<b>Ідентифікація</b> - відповідає на питання Хто це?<br><b>Аутентифікація</b> - Докажи що це ти<br><b>Авторизація</b> - Який доступ до системи ти маєш"
    },
    {
      "title":
          "Навіщо потрібні інструменти розробника в браузері (Chrome DevTools) і як вони допомагають у тестуванні?",
      "content": 
          "<b>Chrome DevTools</b> - це інструмент який допомагає локалізувати дефект у процесі тестування<br><br><b>Elements</b> - дозволяє переглянути структуру сторінки, змінити стилі, додати або видалити елементи<br><br><b>Console</b> - дозволяє виконувати JavaScript код, перевіряти помилки \"клієнта\"<br><br><b>Network</b> - дозволяє переглядати всі запити, що відправляються на сервер, і отримувати відповіді<br><br><b>Sources</b> - дозволяє переглядати структуру як у IDE, відлагоджувати JavaScript код, встановлювати точки зупинки, відстежувати змінні<br><br><b>Application</b> - дозволяє переглядати та редагувати Cache, Cookies, Local Storage, Session Storage"
    },
    {
      "title":
          "Навіщо очищати кеш?",
      "content": 
          "Очищення кешу допомагає вирішити проблеми з відображенням веб-сторінок, видаляючи застарілі або пошкоджені файли. Це також може звільнити місце на пристрої та покращити продуктивність браузера."
    },
    {
      "title":
          "Які види тестування можна застосувати лише до Web?",
      "content": 
          "До веб-тестування можна застосувати такі види тестування:<br><br><b>Крос-браузерне тестування</b>: Перевірка роботи веб-додатка в різних браузерах (Chrome, Firefox, Safari, Edge тощо) для забезпечення сумісності.<br><br><b>Тестування адаптивності (Responsive Testing)</b>: Перевірка коректного відображення та функціонування веб-додатка на різних пристроях і екранах (мобільні телефони, планшети, десктопи).<br><br><b>Тестування продуктивності (Performance Testing)</b>: Перевірка швидкості завантаження сторінок, часу відгуку сервера, стрес-тестування під навантаженням.<br><br><b>Тестування безпеки (Security Testing)</b>: Перевірка захищеності веб-додатка від атак, таких як SQL-ін'єкції, XSS (міжсайтовий скриптинг), CSRF (міжсайтові запити підробки).<br><br><b>Тестування доступності (Accessibility Testing)</b>: Перевірка доступності веб-додатка для користувачів з обмеженими можливостями, відповідність стандартам WCAG.<br><br><b>Тестування SEO (Search Engine Optimization)</b>: Перевірка оптимізації веб-додатка для пошукових систем, правильність мета-тегів, URL-структури, швидкість завантаження.<br><br><b>Тестування інтеграції з API</b>: Перевірка коректної роботи веб-додатка з зовнішніми API та сервісами.<br><br><b>Тестування кешування</b>: Перевірка роботи кешування на стороні клієнта та сервера для оптимізації продуктивності.<br><br><b>Тестування локалізації (Localization Testing)</b>: Перевірка коректного відображення та функціонування веб-додатка на різних мовах і в різних регіонах."
    },
    {
      "title":
          "Що таке API?",
      "content": 
          "<b>API (Application Programming Interface)</b> — це набір правил та механізмів, які визначають, як програми можуть взаємодіяти одна з одною. <br>API визначає, які запити можна робити до програми, які дані можна отримати або надіслати, та які формати даних використовуються для обміну інформацією.<br><br>API може бути <b>внутрішнім (між компонентами однієї програми)</b> або <b>зовнішнім (для взаємодії з іншими програмами або сервісами)</b>.<br><br>API може бути реалізований у вигляді бібліотек, веб-сервісів, SDK (Software Development Kit), фреймворків, або використовувати стандартні протоколи (наприклад, REST, SOAP, GraphQL)."
    },
    {
      "title":
          "Що таке REST API, SOAP? У чому різниця?",
      "content": 
          "<b>REST API</b> (Representational State Transfer) — це архітектурний стиль для створення API, що використовує HTTP для запитів (GET, POST, PUT, DELETE) і працює з ресурсами (URL).<br>Легкий, простий у використанні, масштабований.<br><br><b>SOAP</b> (Simple Object Access Protocol) — це протокол обміну повідомленнями, який використовує XML для передачі даних і суворі стандарти для обробки запитів.<br>Більш складний, забезпечує високий рівень безпеки та транзакцій.<br><br><b>Різниця</b>: REST простіший, швидший і легший у налаштуванні, тоді як SOAP підходить для складних і захищених систем із чіткими стандартами."
    },
    {
      "title":
          "Які методи взаємодії з API існують? У чому різниця між ними?",
      "content": 
          "Існують різні методи взаємодії з API, серед яких найпоширеніші:<br><br><b>REST (Representational State Transfer)</b>:<br>- Використовує HTTP методи (GET, POST, PUT, DELETE) для взаємодії з ресурсами.<br>- Легкий, простий у використанні, масштабований.<br>- Підтримує різні формати даних (JSON, XML).<br><br><b>SOAP (Simple Object Access Protocol)</b>:<br>- Використовує XML для передачі даних.<br>- Більш складний, забезпечує високий рівень безпеки та транзакцій.<br>- Підтримує стандарти WS-Security.<br><br><b>GraphQL</b>:<br>- Запити визначаються клієнтом, що дозволяє отримувати лише необхідні дані.<br>- Використовує один ендпоінт для всіх запитів.<br>- Гнучкий, але може бути складнішим у налаштуванні.<br><br><b>gRPC (Google Remote Procedure Call)</b>:<br>- Використовує HTTP/2 для передачі даних.<br>- Підтримує різні мови програмування.<br>- Висока продуктивність, підходить для мікросервісів.<br><br><b>WebSockets</b>:<br>- Дозволяє двосторонню комунікацію між клієнтом і сервером у реальному часі.<br>- Використовується для чатів, онлайн-ігор, стрімінгу даних.<br><br><b>XML-RPC</b>:<br>- Використовує XML для кодування запитів і відповідей.<br>- Простий у використанні, але менш популярний, ніж REST і SOAP."
    },
    {
      "title":
          "Як можна протестувати API, що там потрібно перевіряти?",
      "content": 
          "Для тестування API необхідно перевіряти наступні аспекти:<br><br><b>Функціональність (Functionality)</b>: Перевірка, чи API виконує свої функції відповідно до вимог. Наприклад, чи повертає правильні дані при запитах.<br><br><b>Валідація даних (Data Validation)</b>: Перевірка коректності вхідних та вихідних даних. Наприклад, чи API правильно обробляє некоректні дані.<br><br><b>Авторизація та аутентифікація (Authorization and Authentication)</b>: Перевірка, чи API правильно обробляє запити з різними рівнями доступу. Наприклад, чи обмежує доступ до певних ресурсів для неавторизованих користувачів.<br><br><b>Продуктивність (Performance)</b>: Перевірка швидкості відповіді API та його здатності обробляти велику кількість запитів. Наприклад, чи API відповідає в межах допустимого часу.<br><br><b>Безпека (Security)</b>: Перевірка захищеності API від атак, таких як SQL-ін'єкції, XSS, CSRF тощо.<br><br><b>Сумісність (Compatibility)</b>: Перевірка роботи API з різними клієнтами та середовищами. Наприклад, чи API працює з різними версіями браузерів.<br><br><b>Обробка помилок (Error Handling)</b>: Перевірка, чи API правильно обробляє помилки та повертає відповідні статус-коди та повідомлення.<br><br><b>Документація (Documentation)</b>: Перевірка наявності та коректності документації для API. Наприклад, чи всі ендпоінти та параметри описані в документації."
    },
    {
      "title":
          "Що таке HTML/CSS/JavaScript?",
      "content": 
        "<b>HTML (HyperText Markup Language)</b> — це стандартна мова розмітки для створення веб-сторінок. Вона використовується для структурування контенту на веб-сторінці за допомогою тегів.<br><br><b>CSS (Cascading Style Sheets)</b> — це мова стилів, яка використовується для опису зовнішнього вигляду HTML-документів. CSS дозволяє змінювати кольори, шрифти, розміри та розташування елементів на сторінці.<br><br><b>JavaScript</b> — це мова програмування, яка використовується для створення динамічного та інтерактивного контенту на веб-сторінках. JavaScript дозволяє реагувати на дії користувача, змінювати контент сторінки без перезавантаження та взаємодіяти з сервером."
    },
    {
      "title":
          "Яку структуру має вебсторінка?",
      "content": 
          "Вебсторінка складається з наступних основних елементів:<br><br><b>DOCTYPE</b>: Вказує тип документа і версію HTML.<br><b>HTML</b>: Кореневий елемент, що містить весь контент сторінки.<br><b>HEAD</b>: Містить метадані про документ, такі як заголовок, посилання на стилі, скрипти та інші ресурси.<br><b>TITLE</b>: Відображає назву сторінки у вкладці браузера.<br><b>BODY</b>: Містить видимий контент сторінки, такий як текст, зображення, відео, форми тощо.<br><b>HEADER</b>: Вміщує заголовок сторінки або розділу.<br><b>MAIN</b>: Основний контент сторінки.<br><b>FOOTER</b>: Нижній колонтитул сторінки, що містить інформацію про авторські права, посилання на політику конфіденційності тощо.<br><b>SECTION</b>: Розділи контенту, що логічно групують пов'язані елементи.<br><b>ARTICLE</b>: Незалежний, самодостатній контент, який може бути розповсюджений окремо.<br><b>ASIDE</b>: Додатковий контент, який доповнює основний, наприклад, бокові панелі.<br><b>NAV</b>: Навігаційні посилання по сайту.<br><b>DIV</b>: Блоковий елемент для групування інших елементів і застосування стилів."
    },
    {
      "title":
          "Які Web elements ви знаєте?",
      "content": 
          "<ul><li><b>Button</b>: Кнопка, яка виконує дію при натисканні.</li><li><b>Input Field</b>: Поле для введення тексту або даних.</li><li><b>Checkbox</b>: Елемент для вибору одного або кількох варіантів.</li><li><b>Radio Button</b>: Елемент для вибору одного варіанту з групи.</li><li><b>Dropdown</b>: Випадаючий список для вибору одного варіанту.</li><li><b>Modal</b>: Вікно, яке з'являється поверх основного контенту для взаємодії з користувачем.</li><li><b>Tooltip</b>: Підказка, яка з'являється при наведенні на елемент.</li><li><b>Slider</b>: Елемент для вибору значення з діапазону.</li><li><b>Progress Bar</b>: Індикатор прогресу виконання завдання.</li><li><b>Tab</b>: Вкладка для перемикання між різними частинами контенту.</li><li><b>Accordion</b>: Елемент для розгортання та згортання контенту.</li><li><b>Card</b>: Контейнер для групування пов'язаного контенту.</li><li><b>Navbar</b>: Панель навігації для переміщення по сайту.</li><li><b>Breadcrumb</b>: Навігаційний ланцюжок для відображення шляху користувача.</li><li><b>Pagination</b>: Елемент для розбиття контенту на сторінки.</li><li><b>Alert</b>: Повідомлення для інформування користувача про важливу інформацію.</li><li><b>Badge</b>: Маленький індикатор для відображення статусу або кількості.</li><li><b>Spinner</b>: Індикатор завантаження.</li></ul>"
    },
    {
        "title":
            "",
        "content": 
            ""
    },
    {
        "title":
            "",
        "content": 
            ""
    },
    {
        "title":
            "",
        "content": 
            ""
    },
    {
        "title":
            "",
        "content": 
            ""
    },
    {
        "title":
            "",
        "content": 
            ""
    },
    {
      "title":
          "Що таке тестування?",
      "content": 
          "Процес, де ми досліджуємо програму чи документацію цієї програми з певною метою (знайти баг, підтвердити, що продукт готовий до релізу тощо)"
    },
    {
      "title":
          "Назвіть цілі тестування",
      "content": 
          "- Виявити дефекти до того, як їх виявляють користувачі.<br>- Надання актуальної інформації про стан продукту зараз.<br>- Перевірка на відповідність ПЗ всім заявленим вимогам."
    },
    {
      "title":
          "Які принципи тестування ви знаєте?",
      "content": 
          "1) <b>Testing shows the presence of defects</b> , not their absence (Тестування демонструє наявність дефектів, але не гарантує їх відсутності).<br><br>2) <b>Exhaustive testing is not possible</b> (Вичерпне тестування неможливе).<br><br>3) <b>Early testing saves time and money</b> (Тестування слід починати на ранніх стадіях життєвого циклу розробки програмного забезпечення, щоб знайти дефекти якомога раніше).<br><br>4) <b>Defects cluster together</b> (Накопичення дефектів. Принцип Паретто: для багатьох явищ 80 відсотків наслідків спричинені 20 відсотками причин).<br><br>5) <b>Beware of the pesticide paradox</b> (Парадокс пестициду. Якщо повторювати ті самі тести знову і знову, то в певний момент цей набір тестів перестане виявляти нові дефекти).<br><br>6) <b>Testing is context dependent</b> (Тестування залежить від контексту).<br><br>7) <b>Absence of errors is a fallacy</b> (Відсутність знайдених дефектів під час тестування не завжди означає готовність продукту до релізу)."
    },
    {
      "title":
          "Коли слід починати тестування?",
      "content": 
          "Слід розпочинати тестування на ранніх стадіях життєвого циклу розробки ПЗ, щоб знайти дефекти якомога раніше.<br>(Пам'ятаємо про принцип №3 – раннє тестування (Early testing))"
    },
    {
      "title":
          "Опишіть життєвий цикл Програмного Забезпечення SDLC",
      "content": 
          "<b>Software development lifecycle</b>  – період часу, який починається з моменту ухвалення рішення про необхідність створення програмного продукту та закінчується в момент його повного вилучення з експлуатації.<br>- Планування та аналіз вимог<br>- Дизайн архітектури продукту<br>- Розробка продукту (програмування)<br>- Тестування продукту<br>- Розгортання продукту (реліз)<br>- Супровід"
    },
    {
      "title":
          "Що таке entry criteria та exit criteria?",
      "content": 
          "<b>Entry criteria</b>  (критерії входу в тестування) визначають умови, які мають бути виконані до початку робіт. Наприклад, визначені вимоги, графік, встановлено програму, що тестується.<br><br><b>Exit criteria</b> (критерії виходу з тестування) визначають, які умови мають бути виконано, щоб завершити рівень тестування або набір тестів. Наприклад, закрито всі завдання і баг репорти, досягнуто певного відсотка пройдених тестів"
    },
    {
      "title":
          "В чому різниця між QC і QA?",
      "content": 
          "<b>Quality Assurance (QA)</b> – QA забезпечує правильність процесу тестування, підходить до контролю якості глобально, стежить за нормалізацією процесів. (Займається тестуванням програми у всіх фазах життєвого циклу програмного забезпечення. Найбільше уваги в роботі приділяє процесам, але також займається тестуванням продукту.)<br><br><b>Quality Control (QC)</b> – QC передбачає контроль за дотриманням вимог. (Займається тестуванням програми у фазах розробки та тестування. На роботі займається продуктом (додатком, сайтом).<br><br>На практиці все робить одна людина"
    },
    {
      "title":
          "Які методології управління проєктами ви знаєте?",
      "content": 
          "Waterfall<br><br>V-модель<br><br>Ітераційна, інкрементальна модель (відмінність: в ітераційній моделі ідея проєкту спочатку маленька, але потім з’являються додаткові функції. В інкрементальній моделі ідея проєкту від самого початку велика)<br><br>Спіральна модель<br><br>Модель хаоса<br><br>Гнучка модель( Agile (еджаїл): Scrum, Kanban)"
    },
    {
      "title":
          "Що таке Waterfall?",
      "content": 
          "Waterfall Model – відома послідовним проходженням стадій, кожна з яких має завершитись повністю до початку наступної. <br><br>Найчастіше використовується в медичних та військових проєктах. <br><br>Переваги: вартість і дедлайни визначені заздалегідь; розробка відбувається швидко; хороший результат лише у проєктах із чітко та заздалегідь визначеними вимогами.<br><br>Недоліки: неможливо повернутись на попередню фазу або повторити фазу; неможливо змінити вимоги під час розробки"
    },
    {
      "title":
          "Що таке Agile?",
      "content": 
          "Методологія Agile - це набір практик, метою яких є оперативна реакція на зміни під час робочого процесу. Такі підходи допомагають командам швидко реагувати на зворотний зв'язок від клієнтів та замовників, тим самим постійно покращуючи вироблений продукт.<br><br>- <b>Цінності Agile</b>:<br><br>- Люди та співпраця важливіші за процеси та інструменти <br>- Працюючий продукт важливіший за вичерпну документацію <br>- Співпраця із замовником важливіша за обговорення умов             контракту<br>- Готовність до змін важливіша за дотримання плану<br><br>- <b>Суть Agile маніфесту</b>:<br><br>- Вся робота над проектом розділяється на короткі цикли (ітерації) і ведеться поетапно;<br>- В кінці кожної ітерації замовник отримує готовий мінімально робочий продукт чи його частину, яку вже можна використовувати;<br>- Протягом всього робочого процесу команда співпрацює з замовником;<br>- Будь-які зміни в проекті вітаються і швидко інтегруються в роботу."
    },
    {
      "title":
          "Що ви знаєте про Scrum?",
      "content": 
          "Підхід передбачає взаємодію кожного етапу розробки ПЗ, як команди розробників (Delivery Team), а й самого замовника (Product owner), і навіть Scrum-майстра.<br><br>Суть даного фреймворку:<br><br>- Робота ділиться на спринти тривалістю 1-4 тижні<br><br>- Перед початком спринта команда сама формує список задач на ітерацію<br><br>- Під час кожного спринта створюється продукт чи послуга, які можна продемонструвати клієнту<br><br>- Після виконання спринту проводиться ретроспектива. Це мітинг, мета якого отримати фідбек від кожного учасника команди, виявити поточні успіхи та проблеми, тобто оцінка та аналіз виконаної роботи.<br><br>- Кожен наступний етап нарощуватиме функціонал проєкту, доки всі функції не будуть реалізовані.<br><br>- Мітинги, які допомагають в процесі роботи: Щоденний стендап, Планування, Ретроспектива та Sprint Review.<br><br>- Обов'язкові ролі: Scrum-master (допомагає вирішити блокери, слідкує за дотриманням скраму) та Product Owner (виставляє пріоритети і цілі спринта)"
    },
    {
        "title":
            "Яка різниця між Scrum і Kanban?",
        "content": 
            "Scrum і Kanban — це два популярні фреймворки для управління проектами, які використовуються в Agile методології. Ось основні відмінності між ними:<br><br><b>Scrum</b>:<br>- Працює на основі спринтів (ітерацій) тривалістю 1-4 тижні.<br>- Має чітко визначені ролі: Scrum Master, Product Owner, Development Team.<br>- Використовує ритуали: планування спринту, щоденні стендапи, огляд спринту, ретроспектива.<br>- Фокусується на доставці робочого продукту в кінці кожного спринту.<br>- Вимагає фіксованого обсягу роботи на спринт.<br><br><b>Kanban</b>:<br>- Не має фіксованих ітерацій, робота виконується безперервно.<br>- Немає чітко визначених ролей, команда працює колективно.<br>- Використовує візуальну дошку (Kanban board) для відстеження прогресу завдань.<br>- Фокусується на оптимізації потоку роботи та зменшенні часу виконання завдань.<br>- Вимагає обмеження кількості завдань у роботі (WIP limits) для уникнення перевантаження.<br><br>Обидва підходи мають свої переваги і можуть використовуватися залежно від потреб команди та проекту."
    },
    {
        "title":
            "Розкажіть про ритуали, цінності та ролі в Scrum",
        "content": 
            "Scrum має кілька ключових ритуалів, цінностей та ролей:<br><br><b>Ритуали (Ceremonies)</b>:<br>- <b>Планування спринту (Sprint Planning)</b>: Зустріч, на якій команда визначає цілі та завдання на наступний спринт.<br>- <b>Щоденні стендапи (Daily Stand-ups)</b>: Короткі щоденні зустрічі, де кожен член команди розповідає про прогрес, плани на день та можливі перешкоди.<br>- <b>Огляд спринту (Sprint Review)</b>: Зустріч в кінці спринту, де команда демонструє виконану роботу та отримує зворотний зв'язок від замовника.<br>- <b>Ретроспектива спринту (Sprint Retrospective)</b>: Зустріч, на якій команда аналізує, що було зроблено добре, що можна покращити та які дії вжити для покращення процесу.<br><br><b>Цінності (Values)</b>:<br>- <b>Фокус (Focus)</b>: Команда зосереджується на цілях спринту та працює над їх досягненням.<br>- <b>Відданість (Commitment)</b>: Кожен член команди бере на себе зобов'язання виконати завдання, які він взяв на себе.<br>- <b>Відкритість (Openness)</b>: Команда відкрито обговорює проблеми, прогрес та ідеї для покращення.<br>- <b>Повага (Respect)</b>: Члени команди поважають один одного, їхні ідеї та внесок у проект.<br>- <b>Сміливість (Courage)</b>: Команда має сміливість приймати складні рішення та вирішувати проблеми.<br><br><b>Ролі (Roles)</b>:<br>- <b>Scrum Master</b>: Відповідає за забезпечення дотримання Scrum-процесів, допомагає команді вирішувати проблеми та усувати перешкоди.<br>- <b>Product Owner</b>: Відповідає за визначення пріоритетів завдань, управління беклогом продукту та забезпечення відповідності вимог замовника.<br>- <b>Development Team</b>: Крос-функціональна команда розробників, яка виконує завдання та створює продукт. Команда самоорганізована та відповідає за виконання завдань спринту."
    },
    {
      "title":
          "Розкажіть про Цикл тестування в житті ПЗ STLC?",
      "content": 
          "Software testing life cycle – це послідовність дій, які проводяться в процесі тестування, за допомогою яких гарантується якість ПЗ та його відповідність вимогам.<br><br>Етапи STLC циклу: <br><br>- <b>Планування тестування (Test Planning)</b>:<br>Визначення стратегії та цілей тестування. Розробка тестового плану, який включає опис області тестування, ресурси, розклад і бюджет.<br><br>- <b>Аналіз вимог (Requirement Analysis)</b>:<br>Вивчення вимог до продукту визначення тестових сценаріїв і кейсів. Створення матриці вимог та тестів для забезпечення покриття.<br><br>- <b>Проектування тестів (Test Design)</b>:<br>Розробка тестових випадків та сценаріїв на основі вимог. Визначення даних, необхідних для виконання тестів.<br><br>- <b>Реалізація тестів (Test Implementation)</b>:<br>Підготовка тестових середовищ та даних. Запуск тестів та реєстрація результатів.<br><br>- <b>Виконання тестів (Test Execution)</b>:<br>Запуск тестових кейсів та сценаріїв. Запис результатів та виявлення дефектів.<br><br>- <b>Звітність та метрики (Test Reporting and Metrics)</b>:<br>Підготовка звітів про статус тестування та якість продукту.<br>Збір та аналіз метрик тестування</b>.<br><br>- <b>Завершення тестування (Test Closure)</b>:<br>Підготовка фінальних звітів та аналіз виконаного тестування.<br>Підготовка тестової документації та архівування ресурсів."
    },
    {
      "title":
          "Які види тестової документації ви знаєте?",
      "content": 
          "- Buisness requirements<br>- Functional requirements<br>- Test strategy<br>- Test plan<br>- Test cases<br>- Checklists<br>- Bug reports<br>- Test summary reports"
    },
    {
      "title":
          "Що таке вимоги і які види вимог ви знаєте? ",
      "content": 
          "Це документ в якому описується що програма має робити і як. <br>Види:<br>- software requirements (реквайментс)<br>- specification  (спесификейшн)<br>- product requirement document<br>- user stories<br>- acceptance criteria"
    },
    {
      "title":
          "Назвіть характеристики гарних вимог",
      "content": 
          "<b>Повнота</b>. Вимоги повинні в повній мірі описати функцію, якунеобхідно реалізувати.<br><br><b>Однозначність</b>. Потрібно уникати розбіжностей в вимогах і не використовувати “плаваючі” слова.<br><br><b>Відсутність протиріч</b>. Різні документи або тексти в одному документі не повинні конфліктувати один з одним.<br><br><b>Здійснюваність</b>. Наскільки вимоги можна реалізувати.<br><br><b>Тестованість</b>. Чи можна протестувати цей функціонал?"
    },
    {
      "title":
          "Що таке User Story?",
      "content": 
          "Це неформальні вимоги, що пишуться в один рядок і складаються з трьох частин:<br> “Як …, я хочу …, щоб …”.<br>Також Юзер сторі - це формат завдання в Джирі, який має підзавдання."
    },
    {
      "title":
          "Що таке Test case?",
      "content": 
          "Це інструкція з тестування функціоналу, яка складається з кроків для відтворення, та очікуваного результату"
    },
    {
      "title":
          "З чого складається Test case?",
      "content": 
          "1) ID <br>2) Title<br>3) Description<br>4) Preconditions<br>5) Steps to reproduce<br>6) Expected result<br>7) Attachments"
    },
    {
      "title":
          "Що таке Checklist?",
      "content": 
          "Це список того що ми повинні протестувати. Це може бути список функціоналу, який ми повинні перевірити, або список тестів, які ми повинні виконати"
    },
    {
      "title":
          "Чим відрізняється Сhecklist від Test case?",
      "content": 
          "Чек ліст простіший, тест кейс об'ємний і детальніший"
    },
    {
      "title":
          "Що таке Test plan? ",
      "content": 
          "Тестовий документ, який описує як буде відбуватись процес тестування."
    },
    {
      "title":
          "З чого складається Test plan?",
      "content": 
          "Описуємо як ми будемо тестувати, що будемо/не будемо тестувати, які рівні/техніки будемо використовувати. Описуємо ролі, обов'язки (roles and responsibilities), ризики та способи їх знизити. Entry, exit критерії. Графік, environment"
    },
    {
      "title":
          "Чим Test plan відрізняється від Test strategy?",
      "content": 
          "Test plan це документ який детально описує тестування на маленькому рівні: продукту, релізу, спринту, юніту, фічі. <br><br>Test strategy описує тестування на рівні проєкта, та більш абстрактно, рідко змінюється."
    },
    {
      "title":
          "Що таке Traceability matrix?",
      "content": 
          "Матриця відслідковуваності - табличка, де у колонках записані вимоги, а у рядках тест-кейси, або частина чек лісту. <br>Таким чином ми можемо відслідкувати які тести покривають вимоги а які ні"
    },
    {
      "title":
          "Що таке баг?",
      "content": 
          "Невідповідність до вимог, недолік в програмі"
    },
    {
      "title":
          "Чим дефект відрізняється від баг-репорта?",
      "content": 
          "Баг-репорт - документ, який описує баг. Дефект - формальна назва багу."
    },
    {
      "title":
          "Що таке bug-report?",
      "content": 
          "Докладна покрокова інструкція для відтворення дефекту"
    },
    {
      "title":
          "З чого складається bug-report?",
      "content": 
          "ID (ідентифікатор)<br>Назва (Title)<br>Короткий опис (Summary)<br>Проєкт (Project)<br>Компонент додатка (Component)<br>Номер версії (Version)<br>Серйозність (Severity)<br>Пріоритет (Priority)<br>Статус (Status)<br>Автор (Author)<br>Призначено на (Assignee)<br>Оточення (Environment: dev/test/staging/prod/etc.)<br>App/build version (версія білда/додатка)<br>Кроки відтворення (Steps to Reproduce)<br>Фактичний Результат (Actual Result)<br>Очікуваний результат (Expected Result)<br><br><b>Додаткові складові Bug report</b>:<br>Screenshots (скріншоти) <br>Video (відео)<br>Credentials (логін + пароль)<br>Browser console errors (логи з браузера)<br>Mobile app logs (логи з мобілки)<br>Server logs (логи із сервера)<br>API Requests (апі запити)<br>Analytics events (івенти з аналітики)<br>Database data (дані з бази даних)<br>Database queries (запити в базу)<br>Date and time (дата і час)<br>Comments/Notes (коментарі/замітки)<br>Link tasks/bugs (підв'язка інших завдань/багів до поточного)<br>HAR archive - архів з усіма запитами в Network"
    },
    {
      "title":
          "Що таке Severity та Priority?",
      "content": 
          "<b>Severity</b> - критичність багу, як сильно він впливає на роботу системи<br><br><b>Priority</b> - як швидко потрібно виправити баг<br><br>На практиці є тільки Priority"
    },
    {
      "title":
          "Наведіть приклад багу з низьким пріоритетом, але високим ступенем впливу",
      "content": 
          "Наприклад, баг з'являється тільки пілсля 30 кроків, та ламає систему. Такий баг важко відтворити, але коли він з'являється, то він критичний"
    },
    {
      "title":
          "Опишіть життєвий цикл bug-report",
      "content": 
          "- New<br>- Open<br>- Assigned<br>- In progress<br>- Duplicate - якщо такий баг вже є<br>- Deferred - якщо баг не терміновий, то його можна перенести на наступний спрінт<br>- Fixed, verified (перевірено)<br>- Reopened - якщо щось невірно пофіксили<br>- Closed"
    },
    {
      "title":
          "Як ви будете тестувати якщо вимог нема?",
      "content": 
          "Буду застосовувати Exploratory testing, дивитися User story, спілкуватися з розробниками, дивитися на аналогічні функції, на конкурентів, питати Product Owner"
    },
    {
      "title":
          "Коли QA-інженер повинен звертатися за допомогою?",
      "content": 
          "В останню чергу після гугла і конфлюенса. Спочатку питати колегу, потім якщо він не знає то ліда, потім продакт овнера"
    },
    {
      "title":
          "Які види тестування ви знаєте?",
      "content": 
          "- Позитивне\\Негативне<br>- Мануальне\\Автоматизоване<br>- Статичне\\Динамічне<br>- Чорний\\Білий\\Сірий ящик<br>- Функціональне\\Нефункціональне<br>- Пов’язане зі змінами."
    },
    {
      "title":
          "Чим верифікація Verification від Validation?",
      "content": 
          "<b>Verification</b> - це перевірка відповідності вимогам<br><br><b>Validation</b> - перевірка на відповідність очікуванням користувача"
    },
    {
      "title":
          "В чому різниця між статичним та динамічним тестуванням?",
      "content": 
          "<b>Статичне тестування</b> - це перевірка документації <br><b>Динамічне</b> - перевірка програми<br> Статичне може виконуватись без запуска коду, а динамічне тільки з кодом."
    },
    {
      "title":
          "В чому різниця між білим, чорним та сірим ящиками?",
      "content": 
          "<b>White box</b> - маємо повний доступ до коду, та тестуємо його <br><b>Grey box</b> - частковий доступ до коду (Postman)<br><b>Black box</b> - не маємо доступу до коду, тестуємо функціонал"
    },
    {
      "title":
          "В чому різниця між позитивним та негативним тестуванням?",
      "content": 
          "<b>Позитивне тестування</b> - коли ми вводим валідні дані і очікуємо на хороший результат. <br><b>Негативне</b> - коли ми вводимо завідома не коректну інформацію і очікуємо на помилку."
    },
    {
      "title":
          "Скільки негативних перевірок може бути за 1 раз? (Реєстрація, скільки полів можна ввести негативних)?",
      "content": 
          "Тільки одне поле заповнюємо негативною інформацією, всі інші - позитивними. Так легше локалізувати дефект"
    },
    {
      "title":
          "В чому різниця між мануальним та автоматизованим тестуванням?",
      "content": 
          "Мануальне тестування - це тестування з використанням клавіатури і миші, а автоматизоване - це коли інженер написав код, який виконує тестування"
    },
    {
      "title":
          "Які рівні тестування ви знаєте?",
      "content": 
          "1) <b>Unit testing</b> - тестування класів, функцій, методів<br>2) <b>Integration testing</b> - тестування взаємодії між компонентами, модулями<br>3) <b>System testing</b> - тестування системи як функціональне, так і нефункціональне<br>4) <b>Acceptance testing</b> - тестування системи відповідно до вимог та потреб кінцевого користувача"
    },
    {
      "title":
          "Які типи нефункціонального тестування ви знаєте?",
      "content": 
          "Performance - Load, Voluem, Stress, Scalability <br>Security - Vulnerbility, Penetratin <br>Usability<br> Installability<br> Localization<br> Існують ще дуже багато видів нефункціонального тестування, під потрібні цілі"
    },
    {
      "title":
          "Які типи тестування, пов’язані зі змінами, ви знаєте?",
      "content": 
          "1) <b>Re-testing</b> - перевірка виправлення багу<br> 2) <b>Sanity testing</b> - детальна перевірка участку коду, наприклад нової фічі<br> 3) <b>Smoke testing</b> - перевірка основного функціоналу, не вдаючись в делалі. Критичній шлях<br> 4) <b>Regression testing</b> - перевірка чи не зламався старий функцілнал, наприклад піля додавання нової фічі"
    },
    {
      "title":
          "Чим Smoke testing відрізняється від Regression testing?",
      "content": 
          "<b>Smoke</b> - перевіряємо критично важливий шлях, функціонал. <br><b>Regression</b> - перевіряємо старий функціонал, щоб він не зламався з новою доробкою. <br>Зазвичай Смоук проводять безпосередньо перед регресією."
    },
    {
      "title":
          "В чому різниця між Smoke та Sanity testing?",
      "content": 
          "<b>Smoke</b> - перевіряємо критично важливий шлях, функціонал. Зазвичай вважається “поверхневимім” тестуванням.<br><b>Sanity</b> - детальне тестування конкретної невеликої частини; перевірка частини, яка найчастіше виходить з ладу; перевірка нового функціонала. "
    },
    {
      "title":
          "Якщо тест кейсів багато, а часу на тестування нема, як обрати тести на регресію?",
      "content": 
          "Потрібно пріоритезувати тест кейси. Необхідно дивитися спочатку на критично важливий функціонал, який є суттю даного ПО. Якщо вистачить часу, то потрібно ще пройтись по самому популярному шляху продукту та перевірити блок, де було більше всього багів."
    },
    {
      "title":
          "Що таке End-to-End testing?",
      "content": 
          "Перевірка всього ланцюжка взаємодії систем у реальних умовах, починаючи від введення даних до кінцевого результату"
    },
    {
      "title":
          "Які ви знаєте техніки тест дизайну?",
      "content": 
          "1) <b>Вичерпне тестування<b/> <br>2) <b>Еквівалентне розділення (Equivalence partitioning)<b/><br>3) <b>Аналіз граничних значень (Boundary values analysis)</b><br>4) <b>Причина/наслідок (Cause/Effect)</b><br>5) <b>Вгадування помилок (Error guessing)</b><br>6) <b>Попарне тестування (Pairwise)</b><br>7) <b>Таблиця прийняття рішень (Decision table)</b><br>8) <b>Діаграма станів і переходів (State transition)</b><br>9) <b>Use case</b><br>10) <b>Дослідницьке тестування (Exploratory testing)</b>"
    },
    {
      "title":
          "В чому різниця між еквівалентним розділенням та граничними значеннями?",
      "content": 
          "<b>Еквівалентне розділення</b> - розбиваємо діапазони на класи. Все що входить в клас - всі значення повинні бути еквівалентні один одному за результатом.<br><br><b>Граничні значення</b> - перевірка границь діапазонів та значення поряд з границею."
    },
    {
      "title":
          "Що таке ad-hoc тестування?",
      "content": 
          "Вільне тестування (ad-hoc testing) – це вид тестування, який виконується без підготовки до тестування продукту, без визначення очікуваних результатів, проєктування тестових сценаріїв. Це неформальне, імпровізаційне тестування."
    },
    {
      "title":
          "Які є види інтеграційного тестування?",
      "content": 
          "Інтеграційне тестування фокусується на перевірці взаємодії між різними компонентами або модулями системи. Основні види інтеграційного тестування включають:<br><br><b>Big Bang Testing</b> (Тестування великого вибуху)<br>Усі модулі об'єднуються одночасно, і тестується вся система як одне ціле.<br>Переваги: Простий підхід, швидка інтеграція.<br>Недоліки: Важко ідентифікувати причину помилок, якщо вони виникають.<br><br><b>Top-Down Testing</b> (Зверху вниз)<br>Тестування починається з найвищого рівня ієрархії модулів і поступово переходить до нижчих рівнів. Модулі, які ще не готові, замінюються драйверами (стабами).<br>Переваги: Легко виявляти логічні помилки.<br>Недоліки: Вимагає багато стабів, може бути складним для реалізації.<br><br><b>Bottom-Up Testing</b> (Знизу вгору)<br>Тестування починається з найнижчого рівня і поступово піднімається до вищих рівнів. Верхні модулі, які ще не готові, замінюються драйверами.<br>Переваги: Легше знайти помилки в нижніх модулях.<br>Недоліки: Неможливо протестувати високорівневу логіку на ранніх етапах.<br><br><b>Sandwich Testing</b> (Сендвіч-тестування)<br>Комбінація Top-Down і Bottom-Up підходів. Модулі тестуються паралельно: одні з верхнього рівня, інші — з нижнього.<br>Переваги: Поєднує переваги обох методів.<br>Недоліки: Висока складність і трудомісткість.<br><br><b>Incremental Testing</b> (Інкрементне тестування)<br>Модулі тестуються та інтегруються поступово, по одному або невеликими групами.<br>Переваги: Легше ізолювати помилки, зручне для великих проектів.<br>Недоліки: Може займати більше часу, ніж Big Bang."
    },
    {
      "title":
          "Що таке дослідницьке тестування (exploratory testing) і чим воно відрізняється від Ad-hoc?",
      "content": 
          "<b>Дослідницьке тестування (exploratory testing)</b> - це процес, у якому тестувальник одночасно досліджує систему, займається тест-дизайном і виконує тести. Для цього підходу потрібно мати досвід тестування на відміну від Ad-hoc"
    },
    {
      "title":
          "Що таке End-to-End тест?",
      "content": 
          "<b>End-to-End (E2E)</b> — це тип тестування, який перевіряє повний робочий процес або функціональність системи від початку до кінця, включаючи всі компоненти, інтеграції, і взаємодії з іншими системами. <br>Мета E2E тестування — впевнитися, що вся система працює як очікується з точки зору кінцевого користувача."
    },
    {
      "title":
          "Що таке тестування безпеки?",
      "content": 
          "<b>Тестування безпеки (Security Testing)</b> — це процес перевірки програмного забезпечення на наявність вразливостей, які можуть бути використані зловмисниками для несанкціонованого доступу до даних або функціоналу системи. <br>Мета тестування безпеки — забезпечити захист даних і запобігти можливим атакам. <br>Види тестування безпеки включають: <br>- <b>Тестування на проникнення (Penetration Testing)</b><br>- <b>Аналіз вразливостей (Vulnerability Assessment)</b><br>- Тестування на відповідність стандартам безпеки (Compliance Testing) та інші."
    },
    {
      "title":
          "Різниця між Load, Volume та Stress тестуванням?",
      "content": 
        "<b>Load Testing</b>: Перевірка продуктивності системи під очікуваним навантаженням. Мета — визначити, як система справляється з нормальною кількістю користувачів або транзакцій.<br><br><b>Volume Testing</b>: Перевірка продуктивності системи при обробці великої кількості даних. Мета — визначити, як система справляється з великими обсягами даних.<br><br><b>Stress Testing</b>: Перевірка продуктивності системи під екстремальним навантаженням, яке перевищує очікуване. Мета — визначити, як система справляється з піковими навантаженнями і чи може вона відновитися після збою."
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "Що таке Postman і для чого він використовується?",
      "content": 
          "Postman — це популярний інструмент для тестування API. <br>Він дозволяє надсилати запити до API, аналізувати відповіді, автоматизувати тести та створювати документацію. <br>Postman використовується для перевірки правильності роботи REST API, тестування функціоналу, перевірки помилок і забезпечення відповідності вимогам."
    },
    {
      "title":
          "Які основні функції Postman ви знаєте?",
      "content": 
          "- Створення та надсилання HTTP-запитів (GET, POST, PUT, DELETE тощо).<br>- Робота з параметрами запиту (Query Params, Path Variables).<br>- Налаштування авторизації (Basic Auth, Bearer Token, OAuth тощо).<br>- Тестування API за допомогою тестових скриптів.<br>- Робота з колекціями (Collections) для групування запитів.<br>- Збереження та використання змінних середовища (Environment Variables).<br>- Аналіз JSON-відповідей та перевірка даних у відповіді.<br>- Автоматизація тестів"
    },
    {
      "title":
          "Як створити новий запит у Postman?",
      "content": 
          "- Відкрити Postman і натиснути \"New\" або \"+\" (новий таб).<br>- Вибрати тип запиту (GET, POST тощо) у випадаючому списку.<br>- Ввести URL API в полі для адреси.<br>- За потреби додати параметри, заголовки (Headers) або тіло запиту (Body).<br>- Натиснути кнопку \"Send\", щоб надіслати запит і переглянути відповідь."
    },
    {
      "title":
          "Як організувати запити в колекції?",
      "content": 
          "1) Створіть нову колекцію: натисніть \"New\" → \"Collection\" і задайте їй ім'я.<br>2) Відкрийте запит, який потрібно додати до колекції.<br>3) Натисніть \"Save\" → виберіть потрібну колекцію → натисніть \"Save to Collection\".<br>4) Всі запити у колекції можна групувати в папки та виконувати послідовно за допомогою Runner."
    },
    {
      "title":
          "Які типи авторизації підтримує Postman?",
      "content": 
          "Postman підтримує кілька типів авторизації:<br><br>- <b>No Auth</b>: Запит без авторизації.<br>- <b>Basic Auth</b>: Простий метод, де логін і пароль передаються в заголовках (Headers) запиту.<br>- <b>Bearer Token</b>: Використовується для передачі токена доступу у заголовках.<br>- <b>OAuth 1.0 і OAuth 2.0</b>: Для складної авторизації з використанням токенів.<br>- <b>API Key</b>: Передача ключа API через параметри запиту, заголовки або тіло.<br>- <b>Digest Auth</b>: Більш безпечна альтернатива Basic Auth, де паролі хешуються.<br>- <b>Hawk Authentication</b>: Захист HTTP запитів із підписами.<br>- <b>AWS Signature</b>: Авторизація для сервісів AWS."
    },
    {
      "title":
          "Що таке токен авторизації, і як ви його використовували?",
      "content": 
          "Токен авторизації — це унікальний ключ, який використовується для підтвердження доступу до API. <br>Він зазвичай генерується сервером і передається в запитах як частина заголовків, параметрів або тіла запиту.<br><br>Використання:<br>У Postman токен передається у вкладці \"Authorization\" (Bearer Token).<br>Ви додаєте токен у відповідне поле, і Postman автоматично додає його до заголовків запиту."
    },
    {
      "title":
          "Як зберігти значення поля з відповіді у форматі JSON у змінну середовища у Postman?",
      "content": 
          "Використати script:<br>var jsonData = pm.response.json();<br>pm.environment.set(\"petId\", jsonData.id)<br><br><b>var jsonData = pm.response.json()</b>;<br>pm.response.json() перетворює тіло відповіді сервера (response body) у формат JSON в об'єкт JavaScript.<br>Результат зберігається у змінній jsonData.<br>pm.environment.set(\"petId\", jsonData.id);<br><br><b>pm.environment.set</b> — функція для створення або оновлення змінної середовища в Postman.<br>\"petId\" — назва змінної середовища.<br>jsonData.id — доступ до значення поля id у відповіді."
    },
    {
      "title":
          "Яка різниця між змінними середовища та глобальними змінними у Postman?",
      "content": 
          "Змінні (variable) середовища доступні лише для певного середовища (environment), а глобальні змінні доступні у всіх середовищах"
    },
    {
      "title":
          "Як використовувати змінну середовища у запиті у Postman?",
      "content": 
          "У запитах змінна середовища вставляється за допомогою синтаксису {{variableName}}"
    },
    {
      "title":
          "Що таке Postman Interceptor?",
      "content": 
          "Postman Interceptor — це розширення для браузера Google Chrome, яке дозволяє:<br>- Перехоплювати мережеві запити (HTTP/HTTPS) прямо з браузера.<br>- Використовувати cookie з браузера в запитах, що виконуються в Postman.<br>Це корисний інструмент для роботи з API, оскільки він допомагає аналізувати реальні запити, які надсилає браузер, і повторювати їх у Postman для тестування"
    },
    {
      "title":
          "Розкажіть про себе.",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    },
    {
      "title":
          "",
      "content": 
          ""
    }
  ]